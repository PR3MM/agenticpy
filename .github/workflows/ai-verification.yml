# This workflow demonstrates a proactive, sandboxed code verification process.
# It automatically triggers on pushes, generates code, verifies it in an isolated
# environment, and creates a pull request only if verification succeeds.
name: AI Code Generation and Verification

on:
  # The workflow will now trigger on every push to any branch.
  # You could restrict this further, e.g., to specific feature branches.
  push:

jobs:
  verify-code:
    # The job will run on the latest version of Ubuntu provided by GitHub.
    runs-on: ubuntu-latest

    # This 'services' block sets up a Docker-in-Docker (DinD) environment.
    # It starts a Docker daemon in a container that our job can connect to.
    services:
      dind:
        image: docker:24-dind
        # --privileged is required for the Docker daemon to run correctly inside a container.
        options: --privileged
        ports:
          # Exposes the Docker daemon's port to the host runner.
          - 2375:2375

    steps:
      # Step 1: Check out the repository code so the workflow can access it.
      - name: Checkout repository
        uses: actions/checkout@v4

      # Step 2: This step simulates an AI generating or modifying code.
      # For this demo, we're just creating a simple Python file.
      - name: AI Generates Code
        id: ai-code-gen
        run: |
          # Create a directory for the app if it doesn't exist
          mkdir -p app
          echo "def new_function(): return True" > app/generated_code.py
          echo "Generated app/generated_code.py"

      # Step 3: Move the verification script into the 'app' directory.
      # This ensures it's available in the Docker mount later on.
      - name: Prepare verification script
        run: mv verify_code.py app/

      # Step 4: Build the verification container that will be used as a sandbox.
      - name: Build Verification Container
        run: |
          # We create the Dockerfile for our verification environment on the fly.
          # This keeps the logic self-contained within the workflow file.
          cat <<EOF > Dockerfile.verify
          # Use a slim Python image to keep the container lightweight.
          FROM python:3.10-slim
          WORKDIR /app

          # Install the Z3 solver, which is a theorem prover from Microsoft.
          # This is the "mathematical verification" tool for our example.
          RUN pip install z3-solver

          # Copy the application and verification code into the container.
          # The context is now the 'app' directory.
          COPY . .

          # Set the default command to run our verification script.
          CMD ["python", "verify_code.py"]
          EOF

          # Build the Docker image from the 'app' directory context.
          docker build -t verification-sandbox -f Dockerfile.verify ./app

      # Step 5: Run the verification logic inside the strictly isolated sandbox.
      - name: Run Verification in Isolated Sandbox
        run: |
          # We run the container with several security restrictions.
          # The mount now correctly contains both the generated code and the script.
          docker run --rm \
            --network=none \
            --read-only \
            -v $(pwd)/app:/app:ro \
            verification-sandbox

      # Step 6: If verification succeeds, create a pull request.
      - name: Create Pull Request on Success
        if: success()
        uses: peter-evans/create-pull-request@v6
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          commit-message: "feat: AI-generated and verified code"
          title: "ðŸ¤– AI Verified: Add new function"
          body: |
            This code was generated by an AI and mathematically verified in a secure sandbox.
            - Verification passed successfully.
            - Ready for human review.
          branch: "ai-verified-code-${{ github.sha }}"
          delete-branch: true
